from flask import Flask, render_template, request
import subprocess
import os
from vulnerability_tester import test_vulnerability

app = Flask(__name__)
app.secret_key = 'supersecretkey'

# Home route
@app.route('/')
def home():
    return render_template('index.html')

# Route for SQL Injection testing
@app.route('/sqli', methods=['GET', 'POST'])
def sqli():
    if request.method == 'POST':
        security_level = request.form.get('security_level')
        
        if security_level:
            # Run the SQLi testing script and capture the output
            sqli_script_path = os.path.join(os.path.dirname(__file__), 'final_sqli1.py')
            try:
                result = subprocess.run(
                    ['python3', sqli_script_path, security_level],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                output = result.stdout
                error_output = result.stderr

                # Combine stdout and stderr to display any errors or results
                combined_output = output + "\n" + error_output if error_output else output

            except Exception as e:
                combined_output = f"Error executing script: {str(e)}"
            
            return render_template('sqli.html', output=combined_output)

        else:
            return render_template('sqli.html', output="Error: Security level not provided.")

    return render_template('sqli.html', output=None)

# Route for Command Injection testing
@app.route('/commandi', methods=['GET', 'POST'])
def commandi():
    if request.method == 'POST':
        security_level = request.form.get('security_level')
        
        if security_level:
            # Run the Command Injection testing script and capture the output
            commandi_script_path = os.path.join(os.path.dirname(__file__), 'commandi2.py')
            try:
                result = subprocess.run(
                    ['python3', commandi_script_path, security_level],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                output = result.stdout
                error_output = result.stderr

                # Combine stdout and stderr to display any errors or results
                combined_output = output + "\n" + error_output if error_output else output

            except Exception as e:
                combined_output = f"Error executing script: {str(e)}"
            
            return render_template('commandi.html', output=combined_output)

        else:
            return render_template('commandi.html', output="Error: Security level not provided.")

    return render_template('commandi.html', output=None)


# Route for Buffer Overflow testing
@app.route('/buffer_overflow', methods=['GET', 'POST'])
def buffer_overflow():
    if request.method == 'POST':
        if 'executable' not in request.files:
            return render_template('buffer_overflow.html', error="No file part")
        file = request.files['executable']
        if file.filename == '':
            return render_template('buffer_overflow.html', error="No selected file")
        
        # Read the file into memory as a binary stream
        file_content = file.read()

        # Call the vulnerability testing function
        vulnerable_payloads, is_vulnerable = test_vulnerability(file_content)
        
        return render_template('buffer_overflow.html', vulnerable=is_vulnerable, vulnerable_payloads=vulnerable_payloads)

    return render_template('buffer_overflow.html')

if __name__ == "__main__":
    app.run(debug=True)
