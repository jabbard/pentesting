import subprocess
import json
import re
import os
import tempfile

# Load the payloads from the JSON file
payloads_file = os.path.join(os.path.dirname(__file__), 'payloads.json')
with open(payloads_file, 'r', encoding='utf-8') as file:
    data = json.load(file)
    payloads = data["payloads"]

# Function to test if an executable is vulnerable to a given payload
def is_vulnerable(executable_content, payload):
    try:
        # Convert payload to string (in case it's an integer)
        payload_str = str(payload)

        # Create a temporary file to execute the binary content
        with tempfile.NamedTemporaryFile(delete=False) as temp_executable:
            temp_executable.write(executable_content)
            temp_executable.flush()  # Ensure the content is written
            temp_executable_path = temp_executable.name

        # Make the temporary file executable
        os.chmod(temp_executable_path, 0o755)

        # Execute the vulnerable app with the payload
        result = subprocess.run(
            [temp_executable_path],
            input=payload_str.encode(),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=3  # Short timeout to detect hanging
        )

        # Clean up the temporary file
        os.remove(temp_executable_path)

        # Check if the result indicates a vulnerability (this is a simplified check)
        if b"Error: Buffer overflow detected" in result.stdout:
            return True
        else:
            return False

    except subprocess.TimeoutExpired:
        # If the app takes too long to respond, it might be vulnerable
        return True
    except Exception as e:
        print(f"Error with payload: {payload_str}, Error: {str(e)}")
        return False

# Function to identify the line of code that handles the input
def find_vulnerable_code_line(source_code, payload):
    # Search for lines where the input is handled and compared
    payload_len = len(payload)
    patterns = [
        rf"if\s+len\(\w+\)\s*>\s*{payload_len}",  # Direct length check with the payload length
        rf"if\s+len\(\w+\)\s*>\s*\w+",  # General length check
        rf"strcpy\(\w+,\s*\w+\)"  # strcpy function as a typical buffer overflow pattern
    ]
    
    for pattern in patterns:
        regex = re.compile(pattern, re.IGNORECASE)
        for i, line in enumerate(source_code):
            if regex.search(line):
                return i + 1, line.strip()  # Return the line number and code

    return None, None  # No match found

# Main function to test the vulnerability
def test_vulnerability(executable_content, source_code_path=None):
    # Dictionary to store vulnerable payloads
    vulnerable_payloads = []

    # Read the source code if provided
    source_code_lines = []
    if source_code_path and os.path.exists(source_code_path):
        with open(source_code_path, 'r', encoding='utf-8') as source_file:
            source_code_lines = source_file.readlines()

    # Test each payload
    for payload in payloads:
        if is_vulnerable(executable_content, payload):
            vulnerable_payloads.append(payload)

    # Determine if the application is vulnerable
    if vulnerable_payloads:
        print("\nThe executable is vulnerable to buffer overflow!")
        
        if source_code_lines:
            # Identify the vulnerable line of code
            payload = vulnerable_payloads[0]  # Use the first vulnerable payload to find the line
            line_number, code_line = find_vulnerable_code_line(source_code_lines, payload)
            
            if line_number and code_line:
                print(f"Vulnerable line found in the source code at line {line_number}:")
                print(f"\t{code_line}")
            else:
                print("Could not identify the specific vulnerable line of code.")
        
        # Print all vulnerable payloads
        print("\nVulnerable Payloads:")
        for payload in vulnerable_payloads:
            print(f"- {payload}")
        
        return vulnerable_payloads, True  # Return the payloads and vulnerability status
    else:
        print("\nThe executable is not vulnerable to buffer overflow based on the tested payloads.")
        return [], False  # Return empty list and False indicating no vulnerability
