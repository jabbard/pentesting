# SQL Injection Vulnerability Testing with DVWA and SQLMap

## Introduction
SQL Injection (SQLi) is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It generally allows attackers to view data that they are not normally able to retrieve. This might include data belonging to other users or any other data that the application itself is able to access.

## Objective
This guide demonstrates how to use SQLMap, an automated tool for SQL injection and database takeover, to test for SQL injection vulnerabilities in the Damn Vulnerable Web Application (DVWA).
![alt text](research\dvwa.png)

## Prerequisites
- A working installation of DVWA.
- SQLMap installed on your system.
- Apache and MySQL services running.
- Basic knowledge of SQL and command line usage.

## DVWA SQL Injection Source Code (Low Security Level)
The source code for the SQL injection vulnerability at the low security level in DVWA is as follows:

```php
<?php
if (isset($_REQUEST['Submit'])) {
    // Get input
    $id = $_REQUEST['id'];

    switch ($_DVWA['SQLI_DB']) {
        case MYSQL:
            // Check database
            $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
            $result = mysqli_query($GLOBALS["___mysqli_ston"], $query) or die('<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>');

            // Get results
            while ($row = mysqli_fetch_assoc($result)) {
                // Get values
                $first = $row["first_name"];
                $last = $row["last_name"];

                // Feedback for end user
                echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
            }

            mysqli_close($GLOBALS["___mysqli_ston"]);
            break;

        case SQLITE:
            global $sqlite_db_connection;

            $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
            try {
                $results = $sqlite_db_connection->query($query);
            } catch (Exception $e) {
                echo 'Caught exception: ' . $e->getMessage();
                exit();
            }

            if ($results) {
                while ($row = $results->fetchArray()) {
                    // Get values
                    $first = $row["first_name"];
                    $last = $row["last_name"];

                    // Feedback for end user
                    echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
                }
            } else {
                echo "Error in fetch " . $sqlite_db->lastErrorMsg();
            }
            break;
    }
}
?>
```

## Code Snippet of the part of the code that makes it vulnerable
![alt text](research\code-snippet.png)

### Explanation
This code is vulnerable because:

- Direct Input Usage: The $id variable directly uses the user input from $_REQUEST['id'] without any sanitization or validation.
- String Concatenation: The SQL query is constructed using string concatenation, incorporating the unsanitized $id variable directly into the query.
- No Parameterization: The code doesn't use prepared statements or parameterized queries, which would help prevent SQL injection.
- Lack of Input Validation: There's no check to ensure that the $id input is of the expected type (e.g., a number).

